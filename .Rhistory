axis.title         = element_blank(),
panel.background   = element_rect(fill  = "grey"),
panel.grid         = element_line(colour = "darkgrey"),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
legend.title       = element_blank(),
legend.margin      = margin(4,0,0,4,"pt"),
legend.background  = element_blank(),
legend.key         = element_blank(),
legend.box.background  = element_rect(linetype="solid", colour ="darkgrey", size = 0.1, fill = "white"),
legend.spacing     = unit(0, "cm"),
legend.key.size    = unit(0.8,"line"),
legend.text        = element_text(size = 6),
legend.direction   = "vertical",
legend.box         = "vertical",
legend.box.just    ='left',
legend.position    = "top")
return(p)
}
xntoyn <- function(xn) return(cumsum(xn))
gg_scale_xy <- list(
scale_x_date(date_breaks = "5 day", date_labels = "%d-%b", expand = c(0,0)),
scale_y_continuous(expand = c(0,0)))
basicmodx <- function(x, pars, len = 0){
q <- floor(pars[1])
a <- pars[2]
b <- pars[3]
modx <- x[1:q]
for(i in (q+1):(length(x)+len)){
modx[i] <- (1-b)*modx[i-1] + a*modx[i-q]
}
return(modx)
}
norm <- function(par, x) return(modnorm(x,basicmodx(x, par)))
normy <- function(par, x, y) return(modnorm(y,xntoyn(basicmodx(x, par))))
normalize <- function(x) return((x-min(x))/(max(x)-min(x)))
basef <- function(lambda,par) {
return(lambda^(par[1]+1)-(1-par[3])*lambda^(par[1])-par[2])
}
basefprime <- function(lambda,par) {
return((par[1]+1)*lambda^(par[1])-(1-par[3])*par[1]*lambda^(par[1]-1))
}
normC <- function(par,x,r){
return(modnorm(x, par*r^(0:(length(x[!is.na(x)])-1))))
}
movingavg <- function(x){
mavgx <- (x[1]+x[2])/2
for(i in 2:(length(x)-1)){
mavgx[i] <- sum(x[(i-1):(i+1)])/3
}
mavgx[length(x)] <- (x[length(x)-1]+x[length(x)])/2
return(mavgx)
}
normper <- function(par, q, x) return(modnorm(x,modxper(par,q,x)))
modxper <- function(par, q, x, len = 0){
#a,b,c1,c2,p1,p2,n1,n2
an   <- par[1]*(1+par[3]*sin(2*pi*(1:(length(x)+len) - par[7])/par[5]))
bn   <- par[2]*(1+par[4]*sin(2*pi*(1:(length(x)+len) - par[8])/par[6]))
modx <- x[1:q]
for(i in (q+1):(length(x)+len)){
modx[i] <- (bn[i]*(1-bn[i-1]))*modx[i-1]/bn[i-1] +
(an[i-q]*bn[i])*modx[i-q]/bn[i-q]
}
return(modx)
}
covidPlots <- function(country, dateBounds, data){
plots <- list()
countryrows <- grep(country, data$location)
countrydat <- data.frame(date = data$date[countryrows],
xn   = data$new_cases[countryrows],
yn   = data$total_cases[countryrows])
countrydatfull <- countrydat[countrydat$date <= dateBounds[2],]
if(nrow(countrydat[countrydat$date < dateBounds[1],]) == 0)
prevcases <- 0
else
prevcases <- sum(countrydat$xn[countrydat$date < dateBounds[1]])
#Specific dates
countrydat <- countrydat[countrydat$date >= dateBounds[1] & countrydat$date <= dateBounds[2],]
#countrydat$xn[countrydat$xn < 0] <- 0
latest_date <- countrydat$date[nrow(countrydat)]
cols <- list(
xn       = wes_palettes$Zissou1[1],
yn       = wes_palettes$Darjeeling2[2],
basexn   = wes_palettes$Darjeeling1[1],
baseyn   = wes_palettes$Darjeeling1[1],
x3       = wes_palettes$FantasticFox1[2],
Crn      = wes_palettes$FantasticFox1[2],
arima    = wes_palettes$Darjeeling1[4],
arimapi  = wes_palettes$Darjeeling1[3],
hw       = wes_palettes$Moonrise1[2],
hwpi     = wes_palettes$Moonrise1[1],
periodic = "magenta4", #wes_palettes$IsleofDogs1[1], #
nn       = wes_palettes$FantasticFox1[4]
)
labs <- list(
xn = list(bquote(.(country)*","~x[n]*"*=new cases/day, actual till"~.(format.Date(latest_date,"%d.%m.%Y")))),
yn = list(bquote(.(country)*","~y[n]*"*=cumulative cases, actual till"~.(format.Date(latest_date,"%d.%m.%Y"))))
)
plots[["xn"]] <- plot_xn(countrydatfull, cols, labs)
plots[["yn"]] <- plot_yn(countrydatfull, cols, labs)
#Basic model: need a,b,q,r using ||x-x*|| and ||y-y*||
##q - Any infected person becomes ill and infectious on the q-th day after infection.
##a - During each day, each ill person at large infects on average a other persons.
##b - During each day, a fraction b of ill people at large gets isolated
forecastlen <- 14
aseq    <- seq(from = 0.1, to = 2.5, length.out = 80)
bseq    <- seq(from = 0.1, to = 0.9, length.out = 80)
qseq    <- 6:8
normdat <- expand.grid(q = qseq, a = aseq, b = bseq)
abnorm  <- apply(normdat, 1, function(x) norm(x, countrydat$xn))
normdat$abnorm  <- abnorm
newnormdat <- normdat %>%
top_n(abnorm ,n = -0.07*nrow(.))
col_grad <- wes_palette("Zissou1", 20, type = "continuous")
tileoptim <- normdat[which.min(normdat$abnorm),1:3]
#tileoptim <- newnormdat[which.min(newnormdat$abnormy),1:3]
optimpars <- c(tileoptim$q, tileoptim$a, tileoptim$b)
plots[["combnorm"]] <- ggplot(newnormdat, aes(x = a, y = b, z = abnorm)) +
geom_contour_filled() +
scale_fill_brewer(palette = "Spectral")
basexn   <- basicmodx(countrydat$xn, optimpars, len = forecastlen)
modeldat <- data.frame(date = c(countrydat$date,latest_date + 1:forecastlen),
basexn = basexn, baseyn = xntoyn(basexn) + prevcases)
#Newtons method, r_1 = r_0 - f(r_0)/f'(r_0)
base_r_zero <- (optimpars[2]/optimpars[3])^(1/(2*optimpars[1]))
base_r_one  <- base_r_zero -basef(base_r_zero,optimpars)/basefprime(base_r_zero,optimpars)
base_r_one  <- round(base_r_one,3)
roptimpars  <- round(optimpars,3)
labs$basexn <- list(bquote("basic model, "~x[n]*"=new cases/day; a="*.(roptimpars[2])*", b="*.(roptimpars[3])*", q="*.(roptimpars[1])*";  r="*.(base_r_one)*"; ||x*-x||="*.(norm(optimpars,countrydat$xn))))
ynnorm      <- modnorm(countrydat$yn, modeldat$baseyn[1:length(countrydat$yn)])
labs$baseyn <- list(bquote("basic model, "~y[n]*"=cumulative cases; a="*.(roptimpars[2])*", b="*.(roptimpars[3])*", q="*.(roptimpars[1])*", ||y*-y||="*.(ynnorm)))
plots[["basexn"]] <- plot_basexn(countrydat, modeldat, cols, labs)
plots[["baseyn"]] <- plot_baseyn(countrydat, modeldat, cols, labs)
optimC <- optim(par = countrydat$xn[1], normC, method = "Brent",
lower = 1, upper = 2*max(countrydat$xn[!is.na(countrydat$xn)]),
x = basexn[1:nrow(countrydat)], r = base_r_one)$par
modeldat$Crn <- optimC*base_r_one^(1:nrow(modeldat))
labs$Crn <- list(bquote(Cr^n*", r="*.(base_r_one)*", C="*.(floor(optimC))))
plots[["Crn"]] <- plot_crn(countrydat, modeldat, cols, labs)
mavgx1 <- movingavg(countrydat$xn[!is.na(countrydat$xn)])
countrydat$mavgx3 <- movingavg(mavgx1)
x3norm  <- modnorm(countrydat$xn,countrydat$mavgx3)
labs$x3 <- list(bquote("moving average x*(3); ||x*(3)-x*||="*.(x3norm)))
plots[["mavgx3"]] <- plot_mavgx3(countrydat, modeldat, cols, labs)
#parameters of the form (ci,pi,ni)
##an = a1 + c1 sin(2??/p1 (n ??? n1))
aseqper <- optimpars[2]*seq(from = 0.8, to = 1.2, length.out = 5)
bseqper <- optimpars[3]*seq(from = 0.8, to = 1.2, length.out = 5)
c_1seq  <- c_2seq <- seq(0.04, 0.2, length.out = 10)
n_1seq  <- n_2seq <- c(1,7)
p_1seq  <- p_2seq <- 6:7
normdatp <- expand.grid(a  = aseqper, b  = bseqper,
c1 = c_1seq,  c2 = c_2seq,
p1 = p_1seq,  p2 = p_2seq,
n1 = n_1seq,  n2 = n_2seq)
pernorm <- apply(normdatp, 1, function(x) normper(x, q = optimpars[1], countrydat$xn))
normdatp$pernorm <- pernorm
peroptim   <- normdatp[which.min(pernorm),1:8]
optpernorm <- normdatp[which.min(pernorm),9]
modeldat$modxPeriodic <- modxper(as.numeric(peroptim),countrydat$xn, q = optimpars[1], forecastlen)
peroptim <- round(as.numeric(peroptim),3)
perparamdat <- data.frame(
x  = modeldat$date,
an = peroptim[1]*(1+peroptim[3]*sin(2*pi*(1:(nrow(modeldat)) - peroptim[7])/peroptim[5])),
bn = peroptim[2]*(1+peroptim[4]*sin(2*pi*(1:(nrow(modeldat)) - peroptim[8])/peroptim[6]))
)
plots[["perparam"]] <- ggplot(perparamdat) +
geom_line(aes(x=x,y=an,col="a_n")) +
geom_line(aes(x=x,y=bn,col="b_n")) +
geom_hline(aes(yintercept = peroptim[1], col = "a"), linetype="dashed") +
geom_hline(aes(yintercept = peroptim[2], col = "b"), linetype="dashed") +
xlab("date") + ylab("") +
scale_color_manual(values = wes_palettes$Rushmore1[c(3,3,5,5)]) +
guides(colour = guide_legend(override.aes = list(linetype =
c("a"="dashed", "a_n"="solid", "b"="dashed", "b_n"="solid")))) +
xntheme() + theme(legend.position = "right")
#a,b,c1,c2,p1,p2,n1,n2
labs$periodic <- list(bquote("periodic model,"~x[n]*"=new cases/day;"
~a*"="*.(peroptim[1])*","~ b*"="*.(peroptim[2])*","
~q*"="*.(optimpars[1])*";"~"||x*-x||="*.(optpernorm)*";"
~c[1]*"="*.(peroptim[3])*","~p[1]*"="*.(peroptim[5])*","
~n[1]*"="*.(peroptim[7])*","~c[2]*"="*.(peroptim[4])*","
~p[2]*"="*.(peroptim[6])*","~n[2]*"="*.(peroptim[8])))
plots[["periodic"]] <- plot_periodic(countrydat, modeldat, cols, labs)
dat_ts <- ts(data = countrydat$xn, frequency = optimpars[1])
countrydat$resid <- residuals(naive(dat_ts))
g1 <- autoplot(dat_ts) + theme(axis.title = element_blank())
g2 <- ggAcf(dat_ts) + ggtitle("")
g3 <- ggPacf(dat_ts) + ggtitle("")
plots[["tsdisplay"]] <- grid.arrange(grobs = list(g1,g2,g3),
layout_matrix = rbind(c(1, 1), c(2, 3)))
plots[["residuals"]] <- gghistogram(dat_ts, add.normal = TRUE)
plots[["tsdecompose"]] <- autoplot(decompose(dat_ts))
if(any(countrydat$xn <= 0)){
plots[["hw"]] <- ggplot(data.frame(x = 0,y = 0)) +
geom_label(x = 0, y = 0, label = "Error: Country data has nonpositive values",
color = "red", size = 5 , fontface = "bold" ) +
xlim(-1,1) + ylim(-1,1) +
theme(axis.line  = element_blank(),
axis.text  = element_blank(),
axis.ticks = element_blank(),
panel.grid = element_blank())
} else{
hwmethod   <- "additive"
xnonlylast <- c(rep(NA, nrow(countrydat)-1), countrydat$xn[length(countrydat$xn)])
#lambda=0 ensures values stay positive
hwfcst     <- forecast::hw(dat_ts, h = forecastlen, seasonal = hwmethod, lambda = 0)
hwfcst$lower[hwfcst$lower[,2] < 0,2] <- 0
#hwfcst$upper[hwfcst$upper[,2] < 0,2] <- 0
#hwfcst$mean[hwfcst$mean < 0] <- 0
hwfcst$fitted[1:optimpars[1]] <- countrydat$xn[1:optimpars[1]]
modeldat$hwxn <- c(hwfcst$fitted, hwfcst$mean)
modeldat$hwlo <- c(hwfcst$fitted, hwfcst$lower[,2])
modeldat$hwhi <- c(hwfcst$fitted, hwfcst$upper[,2])
modeldat$hwyn  <- xntoyn(modeldat$hwxn)+prevcases
modeldat$hwylo <- xntoyn(modeldat$hwlo)+prevcases
modeldat$hwyhi <- xntoyn(modeldat$hwhi)+prevcases
hwnorm <- modnorm(countrydat$xn,hwfcst$fitted)
labs$hw   <- paste0("HoltWinters algorithm,  ||x*-x||=", modnorm(countrydat$xn,hwfcst$fitted))
labs$hwy  <- paste0("HoltWinters algorithm,  ||y*-y||=", modnorm(countrydat$yn,modeldat$hwyn[1:nrow(countrydat)]))
labs$hwpi <- "HW 95% Prediction Interval"
plots[["hw"]]  <- plot_hw(countrydat, modeldat, cols, labs)
plots[["hwy"]] <- plot_hwy(countrydat, modeldat, cols, labs)
}
auto.fit <- auto.arima(dat_ts, lambda = 0) #keep values positive
getArmaModel <- function(arma){
return(paste0("ARIMA(", paste0(arma[c(1,6,2)],collapse = ","), ")(",
paste0(arma[c(3,7,4)], collapse = ","), ")[", arma[5], "]"))
}
arima.fcst <- forecast(auto.fit, level = c(80, 95), h = forecastlen)
arima.fcst$lower[arima.fcst$lower[,2] < 0,2] <- 0
#arima.fcst$upper[arima.fcst$upper[,2] < 0,2] <- 0
arima.fcst$fitted[1:optimpars[1]] <- countrydat$xn[1:optimpars[1]]
#arima.fcst$mean[arima.fcst$mean < 0] <- 0
arimanorm <- modnorm(countrydat$xn,arima.fcst$fitted)
arimalabs    <- getArmaModel(auto.fit$arma)
labs$arima   <- paste0(arimalabs, ", ||x*-x||=", arimanorm)
labs$arimapi <- "ARIMA 95% Prediction Interval"
modeldat$arimaxn <- c(auto.fit$fitted, arima.fcst$mean)
modeldat$arimalo <- c(auto.fit$fitted,arima.fcst$lower[,2])
modeldat$arimahi <- c(auto.fit$fitted,arima.fcst$upper[,2])
modeldat$arimaxn[1:optimpars[1]] <- countrydat$xn[1:optimpars[1]]
modeldat$arimalo[1:optimpars[1]] <- countrydat$xn[1:optimpars[1]]
modeldat$arimahi[1:optimpars[1]] <- countrydat$xn[1:optimpars[1]]
modeldat$arimayn  <- xntoyn(modeldat$arimaxn) + prevcases
modeldat$arimaylo <- xntoyn(modeldat$arimalo) + prevcases
modeldat$arimayhi <- xntoyn(modeldat$arimahi) + prevcases
labs$arimay  <- paste0(arimalabs, ", ||y*-y||=", modnorm(countrydat$yn,modeldat$arimayn[1:nrow(countrydat)]))
plots[["arima"]] <- plot_arima(countrydat, modeldat, cols, labs)
plots[["arimay"]] <- plot_arimay(countrydat, modeldat, cols, labs)
plots[["hwarima"]] <- plot_hwarima(countrydat, modeldat, cols, labs)
#Box-Cox transformation with lambda=0 to ensure the forecasts stay positive.
nnfit   <- nnetar(dat_ts, p = auto.fit$arma[1], lambda = 0, repeats = 20, maxit = 50)
nn.fcst <- forecast(nnfit, h = forecastlen)
nn.fcst$mean[nn.fcst$mean < 0] <- 0
nn.fcst$fitted[1:optimpars[1]] <- countrydat$xn[1:optimpars[1]]
modeldat$nnxn <- c(nn.fcst$fitted, nn.fcst$mean)
modeldat$nnyn <- xntoyn(modeldat$nnxn) + prevcases
labs$nn  <- paste0(nnfit$method, ", ||x*-x||=", modnorm(countrydat$xn,nn.fcst$fitted))
labs$nny <- paste0(nnfit$method, ", ||y*-y||=", modnorm(countrydat$yn,modeldat$nnyn[1:nrow(countrydat)]))
plots[["nn"]] <- plot_nn(countrydat, modeldat, cols, labs)
plots[["nny"]] <- plot_nny(countrydat, modeldat, cols, labs)
return(plots)
}
grigorDates <- c("2020-04-26", "2020-06-09")
datebounds <- list(
"Italy"         = c("2021-01-02", "2021-02-16"),
"United States" = c("2021-01-06", "2021-02-16"),
"Ireland"       = c("2021-01-12", "2021-02-16"),
"Germany"       = c("2021-01-06", "2021-02-16")
#"Netherlands"   = c("2021-01-06", "2021-02-16"),
#"Spain"         = c("2021-01-06", "2021-02-16"),
#"UK"            = c("2021-01-06", "2021-02-16")
)
owiddat    <- owiddat[!is.na(owiddat$new_cases),]
totaldates <- owiddat$date
totaldat   <- aggregate(owiddat$new_cases, by=list(totaldates), sum)
colnames(totaldat) <- c("Date", "Cases")
latest_date <- totaldat$Date[nrow(totaldat)]
wt_title <- sprintf('Global Total =%s as at %s',
format(sum(totaldat$Cases), big.mark=",", scientific=FALSE),
format.Date(latest_date, "%B %d, %Y"))
plotslist[["WorldTotal"]][["xn"]] <- plot_worldtotal(totaldat)
for(country in names(datebounds)){
plotslist[[country]] <- covidPlots(country, datebounds[[country]], owiddat)
}
plotslist$Ireland$basexn
plotslist$Ireland$nn
plotslist$Ireland$arima
plotslist$Ireland$hw
plotslist$Ireland$periodic
plotslist$Italy$periodic
plotslist$`United States`$periodic
plotslist$Germany$periodic
plotslist$`United States`$periodic
plotslist$`United States`$perparam
# load required libraries
library(ggplot2)
library(rgdal)
library(raster)
library(wesanderson)
library(dplyr)
countyplotlist <- list()
# read the shape files
setwd("~/GitHub/TCD_FinalYearProject/Data/")
countyshp <- readOGR("counties/counties.shp")
worldshp  <- readOGR("world/world.shp")
# read the county case data
countycases <- read.csv("https://opendata.arcgis.com/datasets/d9be85b30d7748b5b7c09450b8aede63_0.csv?outSR=%7B%22latestWkid%22%3A3857%2C%22wkid%22%3A102100%7D")
countycases$TimeStamp <- as.Date(countycases$TimeStamp)
# just latest date
latest_date <- countycases$TimeStamp[nrow(countycases)]
latest_dat  <- countycases[countycases$TimeStamp == latest_date,]
fortnightbefore_dat <- countycases[countycases$TimeStamp == latest_date-13,]
latest_dat$ConfirmedCovidCases <- latest_dat$ConfirmedCovidCases - fortnightbefore_dat$ConfirmedCovidCases
# make shape data ggplot-friendly
countyshp@data$id <- rownames(countyshp@data)
countyshp.points  <- fortify(countyshp, region="id")
counties <- inner_join(countyshp.points, countyshp@data, by="id")
counties$CountyName <- gsub("County ", "", counties$NAME_EN)
# join case numbers for latest date to county data, in order to colour nicely
countycase_map <- left_join(counties, latest_dat, by=c("CountyName" = "CountyName"))
# color gradient
col_grad <- wes_palette("Zissou1", 20, type = "continuous")
# county plots
countyplotlist[["rep"]] <- ggplot(countycase_map) +
aes(long, lat, group=group, fill=PopulationProportionCovidCases) +
geom_polygon(colour="grey40") + labs(fill = "Cases per 100k") +
scale_fill_gradientn(colours = col_grad) +
geom_text(data = latest_dat, aes(x = Long, y = Lat, label = floor(PopulationProportionCovidCases)), inherit.aes = FALSE) +
ggtitle("Cases in Ireland per 100,000 population by county",
subtitle = paste("Cumulative, up to", format.Date(latest_date, "%B %d, %Y"))) +
theme(axis.title        = element_blank(),
axis.text         = element_blank(),
axis.ticks        = element_blank(),
panel.background  = element_blank(),
legend.title      = element_blank(),
legend.background = element_blank(),
legend.position   = c(0.25,0.87))
countyplotlist[["fourteendaycases"]] <- ggplot(countycase_map) +
aes(long, lat, group=group, fill=ConfirmedCovidCases) +
geom_polygon(colour="grey40") + labs(fill = "Cases") +
scale_fill_gradientn(colours = col_grad) +
geom_text(data = latest_dat, aes(x = Long, y = Lat, label = floor(ConfirmedCovidCases)), inherit.aes = FALSE) +
ggtitle("Cases in Ireland by county",
subtitle = paste("From", format.Date(latest_date-13, "%B %d, %Y"),
"to", format.Date(latest_date, "%B %d, %Y"))) +
theme(axis.title        = element_blank(),
axis.text         = element_blank(),
axis.ticks        = element_blank(),
panel.background  = element_blank(),
legend.title      = element_blank(),
legend.background = element_blank(),
legend.position   = c(0.25,0.87))
countyplotlist[["names"]] <- ggplot(countycase_map) +
aes(long, lat, group=group, fill=PopulationProportionCovidCases) +
geom_polygon(colour="grey40") + labs(fill = "Cases per 100k") +
scale_fill_gradientn(colours = col_grad) +
geom_text(data = latest_dat, aes(x = Long, y = Lat, label = CountyName), size=3,inherit.aes = FALSE) +
ggtitle("Cases in Ireland per 100,000 population by county",
subtitle = paste("Cumulative, up to", format.Date(latest_date, "%B %d, %Y"))) +
theme(axis.title       = element_blank(),
axis.text        = element_blank(),
axis.ticks       = element_blank(),
panel.background  = element_blank(),
legend.title      = element_blank(),
legend.background = element_blank(),
legend.position   = c(0.25,0.87))
countyplotlist[["blank"]] <- ggplot(countycase_map) +
aes(long, lat, group=group, fill=PopulationProportionCovidCases) +
geom_polygon(colour="grey40") + labs(fill = "Cases per 100k") +
scale_fill_gradientn(colours = col_grad) +
ggtitle("Cases in Ireland per 100,000 population by county",
subtitle = paste("Cumulative, up to", format.Date(latest_date, "%B %d, %Y"))) +
theme(axis.title       = element_blank(),
axis.text        = element_blank(),
axis.ticks       = element_blank(),
panel.background  = element_blank(),
legend.title      = element_blank(),
legend.background = element_blank(),
legend.position   = c(0.25,0.87))
#webdat <- read.csv("https://opendata.ecdc.europa.eu/covid19/casedistribution/csv")
owiddat <- read.csv("https://covid.ourworldindata.org/data/owid-covid-data.csv")
# just latest date
latest_date <- as.Date(owiddat$date[nrow(owiddat)-1], tryFormats = c("%Y-%m-%d"))
latest_dat  <- owiddat[owiddat$date == latest_date,]
fortnightRows <- owiddat$date >= latest_date-13 & owiddat$date <= latest_date
fortnightCases <- aggregate(owiddat$new_cases_per_million[fortnightRows],
by=list(owiddat$location[fortnightRows]), function(x) sum(x[!is.na(x)]))
colnames(fortnightCases) <- c("location", "fortnight_cases_per_million")
latest_dat <- left_join(latest_dat, fortnightCases, by=c("location" = "location"))
# make shape data ggplot-friendly
worldshp@data$id <- rownames(worldshp@data)
worldshp.points  <- fortify(worldshp, region="id")
countries <- inner_join(worldshp.points, worldshp@data, by="id")
# join case numbers for latest date to country data, in order to colour nicely
world_map <- left_join(countries, latest_dat, by=c("CNTRY_NAME" = "location"))
world_map <- world_map[world_map$lat >= -75,]
worldplot <- list()
worldplot[["blank"]] <- ggplot(world_map) +
aes(long, lat, group=group, fill=fortnight_cases_per_million) +
geom_polygon(colour="grey40") + labs(fill = "Cases per million") +
scale_fill_gradientn(colours = col_grad) +
ggtitle("Cases per 1 million population by country",
subtitle =  paste("From", format.Date(latest_date-13, "%B %d, %Y"), "to", format.Date(latest_date, "%B %d, %Y"))) +
theme(axis.title       = element_blank(),
axis.text        = element_blank(),
axis.ticks       = element_blank(),
panel.background = element_blank(),
plot.margin      = margin(0, 0, 0, 0, "cm"),
legend.title      = element_blank(),
legend.background = element_blank(),
legend.position   = c(0.1,0.4))
worldplot[["cumulative"]] <- ggplot(world_map) +
aes(long, lat, group=group, fill=total_cases_per_million) +
geom_polygon(colour="grey40") + labs(fill = "Cases per million") +
scale_fill_gradientn(colours = col_grad) +
ggtitle("Total cases per 1 million population by country",
subtitle =  paste("Up to", format.Date(latest_date, "%B %d, %Y"))) +
theme(axis.title       = element_blank(),
axis.text        = element_blank(),
axis.ticks       = element_blank(),
panel.background = element_blank(),
plot.margin      = margin(0, 0, 0, 0, "cm"),
legend.title      = element_blank(),
legend.background = element_blank(),
legend.position   = c(0.1,0.4))
europe_map <- world_map[world_map$long >= -20 & world_map$long <= 40,]
europe_map <- europe_map[europe_map$lat >= 35 & europe_map$lat <= 75,]
worldplot[["europe"]] <- ggplot(europe_map) +
aes(long, lat, group=group, fill=fortnight_cases_per_million) +
geom_polygon(colour="grey40") + labs(fill = "Cases per million") +
scale_fill_gradientn(colours = col_grad) +
ggtitle("Total cases per 1 million population by country",
subtitle =  paste("From", format.Date(latest_date-13, "%B %d, %Y"), "to", format.Date(latest_date, "%B %d, %Y"))) +
theme(axis.title       = element_blank(),
axis.text        = element_blank(),
axis.ticks       = element_blank(),
panel.background = element_blank(),
plot.margin      = margin(0, 0, 0, 0, "cm"),
legend.title      = element_blank(),
legend.background = element_blank(),
legend.position   = c(0.1,0.3))
countyplotlist$rep
countyplotlist$fourteendaycases
for(p in names(countyplotlist)){
ggsave(filename = paste0("county-", p, ".pdf"),
plot     = countyplotlist[[p]],
path     = "Plots",
height   = 14,
width    = 14,
units    = "cm"
)
}
for(p in names(worldplot)){
ggsave(filename = paste0("world-", p, ".png"),
plot     = worldplot[[p]],
path     = "Plots",
height   = 14,
width    = 20,
units    = "cm"
)
}
setwd("~/GitHub/TCD_FinalYearProject")
for(p in names(countyplotlist)){
ggsave(filename = paste0("county-", p, ".pdf"),
plot     = countyplotlist[[p]],
path     = "Plots",
height   = 14,
width    = 14,
units    = "cm"
)
}
for(p in names(worldplot)){
ggsave(filename = paste0("world-", p, ".png"),
plot     = worldplot[[p]],
path     = "Plots",
height   = 14,
width    = 20,
units    = "cm"
)
}
owiddat    <- owiddat[!is.na(owiddat$new_cases),]
totaldates <- owiddat$date
totaldat   <- aggregate(owiddat$new_cases, by=list(totaldates), sum)
colnames(totaldat) <- c("Date", "Cases")
latest_date <- totaldat$Date[nrow(totaldat)]
wt_title <- sprintf('Global Total =%s as at %s',
format(sum(totaldat$Cases), big.mark=",", scientific=FALSE),
format.Date(latest_date, "%B %d, %Y"))
plotslist[["WorldTotal"]][["xn"]] <- plot_worldtotal(totaldat)
plotslist[["WorldTotal"]][["xn"]]
owiddat$date <- as.Date(owiddat$date, tryFormats = c("%Y-%m-%d"))
owiddat    <- owiddat[!is.na(owiddat$new_cases),]
totaldates <- owiddat$date
totaldat   <- aggregate(owiddat$new_cases, by=list(totaldates), sum)
colnames(totaldat) <- c("Date", "Cases")
latest_date <- totaldat$Date[nrow(totaldat)]
wt_title <- sprintf('Global Total =%s as at %s',
format(sum(totaldat$Cases), big.mark=",", scientific=FALSE),
format.Date(latest_date, "%B %d, %Y"))
plotslist[["WorldTotal"]][["xn"]] <- plot_worldtotal(totaldat)
plotslist[["WorldTotal"]][["xn"]]
ggsave(filename = paste0("WorldTotal-xn.pdf"),
plot     = plotslist[["WorldTotal"]][["xn"]],
path     = "./Plots",
height   = 10,
width    = 14,
units    = "cm"
)
plotslist$`United States`$combnorm
plotslist$Italy$combnorm
