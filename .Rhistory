labs$hw   <- paste0("HoltWinters algorithm,  ||x*-x||=", modnorm(countrydat$xn,hwfcst$fitted))
labs$hwy  <- paste0("HoltWinters algorithm,  ||y*-y||=", modnorm(countrydat$yn,modeldat$hwyn[1:nrow(countrydat)]))
labs$hwpi <- "HW 95% Prediction Interval"
plots[["hw"]]  <- plot_hw(countrydat, modeldat, cols, labs)
plots[["hwy"]] <- plot_hwy(countrydat, modeldat, cols, labs)
}
auto.fit <- auto.arima(dat_ts, lambda = 0) #keep values positive
getArmaModel <- function(arma, pdq = c(1,6,2), PDQ = c(3,7,4), s=5){
return(paste0("ARIMA(", paste0(arma[pdq], collapse = ","), ")(",
paste0(arma[PDQ], collapse = ","), ")[", arma[s], "]"))
}
arima.fcst <- forecast(auto.fit, level = c(80, 95), h = forecastlen)
arima.fcst$fitted[1:q] <- countrydat$xn[1:q]
arimanorm <- modnorm(countrydat$xn,arima.fcst$fitted)
arimalabs    <- getArmaModel(auto.fit$arma)
labs$arima   <- paste0(arimalabs, ", ||x*-x||=", arimanorm)
labs$arimapi <- "ARIMA 95% Prediction Interval"
modeldat$arimaxn <- c(auto.fit$fitted, arima.fcst$mean)
modeldat$arimalo <- c(auto.fit$fitted,arima.fcst$lower[,2])
modeldat$arimahi <- c(auto.fit$fitted,arima.fcst$upper[,2])
modeldat$arimaxn[1:q] <- countrydat$xn[1:q]
modeldat$arimalo[1:q] <- countrydat$xn[1:q]
modeldat$arimahi[1:q] <- countrydat$xn[1:q]
modeldat$arimayn  <- xntoyn(modeldat$arimaxn) + prevcases
modeldat$arimaylo <- xntoyn(modeldat$arimalo) + prevcases
modeldat$arimayhi <- xntoyn(modeldat$arimahi) + prevcases
labs$arimay  <- paste0(arimalabs, ", ||y*-y||=", modnorm(countrydat$yn,modeldat$arimayn[1:nrow(countrydat)]))
plots[["arima"]] <- plot_arima(countrydat, modeldat, cols, labs)
plots[["arimay"]] <- plot_arimay(countrydat, modeldat, cols, labs)
plots[["hwarima"]] <- plot_hwarima(countrydat, modeldat, cols, labs)
nHidden <- max(1,floor(0.5*(1+auto.fit$arma[1]+auto.fit$arma[3])))
#Box-Cox transformation with lambda=0 to ensure the forecasts stay positive.
nnfit   <- nnetar(dat_ts, p = auto.fit$arma[1], P = auto.fit$arma[3], size = nHidden, lambda = 0, repeats = 20, maxit = 50)
nn.fcst <- forecast(nnfit, h = forecastlen)
nn.fcst$mean[nn.fcst$mean < 0] <- 0
nn.fcst$fitted[1:q] <- countrydat$xn[1:q]
modeldat$nnxn <- c(nn.fcst$fitted, nn.fcst$mean)
modeldat$nnyn <- xntoyn(modeldat$nnxn) + prevcases
labs$nn  <- paste0(nnfit$method, ", ||x*-x||=", modnorm(countrydat$xn,nn.fcst$fitted))
labs$nny <- paste0(nnfit$method, ", ||y*-y||=", modnorm(countrydat$yn,modeldat$nnyn[1:nrow(countrydat)]))
plots[["nn"]] <- plot_nn(countrydat, modeldat, cols, labs)
plots[["nny"]] <- plot_nny(countrydat, modeldat, cols, labs)
return(plots)
}
grigorDates <- c("2020-04-26", "2020-06-09")
datebounds <- list(
"Italy"         = c("2021-01-02", "2021-02-16"),
"United States" = c("2021-01-06", "2021-02-16"),
"Ireland"       = c("2021-01-12", "2021-02-16"),
"Germany"       = c("2021-01-06", "2021-02-16")
#"Netherlands"   = c("2021-01-06", "2021-02-16"),
#"Spain"         = c("2021-01-06", "2021-02-16"),
#"UK"            = c("2021-01-06", "2021-02-16")
)
owiddat     <- owiddat[!is.na(owiddat$new_cases),]
totaldat    <- owiddat[owiddat$location == "World",]
latest_date <- totaldat$date[nrow(totaldat)]
wt_title <- sprintf('Global Total =%s as at %s',
format(sum(totaldat$new_cases), big.mark=",", scientific=FALSE),
format.Date(latest_date, "%B %d, %Y"))
plotslist[["WorldTotal"]][["xn"]] <- plot_worldtotal(totaldat)
for(country in names(datebounds)){
plotslist[[country]] <- covidPlots(country, datebounds[[country]], owiddat)
}
multidates <- list(
"Italy"         = list(c("2020-12-16", "2021-01-01"),
c("2021-01-02", "2021-01-30")),
"United States" = list(c("2020-12-16", "2021-01-08"),
c("2021-01-09", "2021-01-30")),
"Ireland"       = list(c("2020-12-16", "2021-01-07"),
c("2021-01-08", "2021-01-30"))
)
multiphasePlots <- function(country, dates, data){
plots <- list()
crows <- grep(country, data$location)
countrydat <- data.frame(date = data$date[crows],
xn = data$new_cases[crows], yn = data$total_cases[crows])
if(nrow(countrydat[countrydat$date < dates[[1]][1],]) == 0)
beforecumcases <- 0
else
beforecumcases <- sum(countrydat$xn[countrydat$date < dates[[1]][1]])
countrydat  <- countrydat[countrydat$date >= dates[[1]][1],]
countrydat  <- countrydat[countrydat$date <= dates[[length(dates)]][2],]
latest_date <- countrydat$date[nrow(countrydat)]
forecastlen <- 5
multimodx <- function(x, multix, pars, oldp = rep(1,10), start=FALSE, len = 0){
q <- floor(pars[1])
a <- pars[2]
b <- pars[3]
fitstd <- length(multix)+1
if(start){
multix[fitstd:(fitstd+q-1)] <- x[1:q]
for(i in (fitstd+q):(fitstd+length(x)+len-1)){
multix[i] <- (1-b)*multix[i-1] + a*multix[i-q]
}
} else {
for(i in (fitstd):(fitstd+length(x)+len-1)){
multix[i] <- (1-b)*multix[i-1] + a*multix[i-q]
}
#multix[fitstd] <- b/oldp[[3]]*((1-oldp[[3]])*multix[fitstd-1] + oldp[[2]]*multix[fitstd-q])
#for(i in (fitstd+1):(fitstd+q-1)){
#  multix[i] <- (1-b)*multix[i-1] + b/oldp[[3]]*oldp[[2]]*multix[i-q]
#}
#for(i in (fitstd+q):(fitstd+length(x)+len-1)){
#  multix[i] <- (1-b)*multix[i-1] + a*multix[i-q]
#}
}
return(multix)
}
multimodxper <- function(par, q=7, x, multix, oldp = rep(1,10), start=FALSE, len = 0){
#a,b,c1,c2,p1,p2,n1,n2
#first day of this phase
fitstd <- length(multix)+1
an  <- par[1]*(1+par[3]*sin(2*pi*(1:(fitstd+length(x)+len-1) - par[7])/par[5]))
bn  <- par[2]*(1+par[4]*sin(2*pi*(1:(fitstd+length(x)+len-1) - par[8])/par[6]))
if(start){
multix[fitstd:(fitstd+q-1)] <- x[1:q]
for(i in (fitstd+q):(fitstd+length(x)+len-1)){
multix[i] <- (bn[i]*(1-bn[i-1]))*multix[i-1]/bn[i-1] +
(an[i-q]*bn[i])*multix[i-q]/bn[i-q]
}
} else {
for(i in fitstd:(fitstd+length(x)+len-1)){
multix[i] <- (bn[i]*(1-bn[i-1]))*multix[i-1]/bn[i-1] +
(an[i-q]*bn[i])*multix[i-q]/bn[i-q]
}
}
return(multix)
}
#Specific dates
multimodel  <- c()
multimodelp <- c()
phasepars   <- list()
for(i in 1:length(dates)){
phase    <- dates[[i]]
phasedat <- countrydat[countrydat$date >= phase[1] & countrydat$date <= phase[2],]
#get basic model for each phase first in order to get
# starting a and b to guess for periodic an and bn
aseq    <- seq(from = 0.1, to = 2.5, length.out = 50)
bseq    <- seq(from = 0.1, to = 0.9, length.out = 50)
qseq    <- 6:8
normdat <- expand.grid(q = qseq, a = aseq, b = bseq)
if(i == 1)
abnorm <- apply(normdat, 1, function(x) modnorm(multimodx(phasedat$xn, multimodel, x, start=TRUE), phasedat$xn))
else
abnorm <- apply(normdat, 1, function(x) modnorm(multimodx(phasedat$xn, multimodel, x, oldp = phasepars[[i-1]])[length(multimodel) + 1:nrow(phasedat)], phasedat$xn))
normalize <- function(x){
return((x-min(x))/(max(x)-min(x)))
}
normdat$abnorm  <- abnorm
#newnormdat      <- normdat %>% top_n(abnorm,n = -0.1*nrow(.))
#if(i == 1)
#  abnormy <- apply(newnormdat, 1, function(x) modnorm(beforecumcases + xntoyn(multimodx(phasedat$xn, multimodel, x[1:3], start=TRUE)), phasedat$yn))
#else
#  abnormy <- apply(newnormdat, 1, function(x) modnorm(beforecumcases + xntoyn(multimodx(phasedat$xn, multimodel, x[1:3], oldp = phasepars[[i-1]]))[length(multimodel)+1:nrow(phasedat)], phasedat$yn))
#newnormdat$abnormy  <- normalize(abnormy)
#newnormdat$combnorm <- newnormdat$abnorm + newnormdat$abnormy
tileoptim <- normdat[which.min(normdat$abnorm),1:3]
#tileoptim <- newnormdat[which.min(newnormdat$combnorm),1:3]
optimpars <- c(tileoptim$q, tileoptim$a, tileoptim$b)
q <- optimpars[1]
a <- optimpars[2]
b <- optimpars[3]
phasepars[[i]] <- round(optimpars,3)
if(i == 1 & i != length(dates))
multimodel <- multimodx(phasedat$xn, multimodel, optimpars, start=TRUE)
if(i == 1 & i == length(dates))
multimodel <- multimodx(phasedat$xn, multimodel, optimpars, start=TRUE, len=forecastlen)
if(i > 1 & i == length(dates))
multimodel <- multimodx(phasedat$xn, multimodel, optimpars, oldp = phasepars[[i-1]], len=forecastlen)
if(length(dates) > 2 & i %in% 2:(length(dates)-1))
multimodel <- multimodx(phasedat$xn, multimodel, optimpars, oldp = phasepars[[i-1]])
aseqper <- a*seq(from = 0.7, to = 1.3, length.out = 10)
bseqper <- b*seq(from = 0.7, to = 1.3, length.out = 10)
c_1seq  <- c_2seq <- seq(0.04, 0.2, length.out = 10)
n_1seq  <- n_2seq <- c(1,7)
p_1seq  <- p_2seq <- 6:7
normdatp <- expand.grid(a  = aseqper, b  = bseqper,
c1 = c_1seq,  c2 = c_2seq,
p1 = p_1seq,  p2 = p_2seq,
n1 = n_1seq,  n2 = n_2seq)
if(i == 1)
pernorm <- apply(normdatp, 1, function(par) modnorm(multimodxper(par, q = optimpars[1], phasedat$xn, multimodelp, start=TRUE), phasedat$xn))
else
pernorm <- apply(normdatp, 1, function(par) modnorm(multimodxper(par, q = optimpars[1], phasedat$xn, multimodelp)[length(multimodelp)+1:nrow(phasedat)], phasedat$xn))
normdatp$pernorm <- normalize(pernorm)
newnormdatp <- normdatp %>% top_n(pernorm,n = -0.05*nrow(.))
if(i == 1)
pernormy <- apply(newnormdatp, 1, function(par) modnorm(beforecumcases+xntoyn(multimodxper(par, q = optimpars[1], phasedat$xn, multimodelp, start=TRUE)), phasedat$yn))
else
pernormy <- apply(newnormdatp, 1, function(par) modnorm(beforecumcases+xntoyn(multimodxper(par, q = optimpars[1], phasedat$xn, multimodelp))[length(multimodelp)+1:nrow(phasedat)], phasedat$yn))
newnormdatp$pernormy <- normalize(pernormy)
newnormdatp$combnorm <- newnormdatp$pernorm + newnormdatp$pernormy
peroptim <- as.numeric(newnormdatp[which.min(newnormdatp$combnorm),1:8])
phasepars[[i]] <- c(phasepars[[i]],round(peroptim,3))
if(i == 1 & i != length(dates))
multimodelp <- multimodxper(peroptim, q = q, phasedat$xn, multimodelp, start=TRUE)
if(i == 1 & i == length(dates))
multimodelp <- multimodxper(peroptim, q = q, phasedat$xn, multimodelp, start=TRUE, len=forecastlen)
if(i > 1 & i == length(dates))
multimodelp <- multimodxper(peroptim, q = q, phasedat$xn, multimodelp, len=forecastlen)
if(length(dates) > 2 & i %in% 2:(length(dates)-1))
multimodelp <- multimodxper(peroptim, q = q, phasedat$xn, multimodelp)
}
cols <- list(
xn       = wes_palettes$Zissou1[1],
yn       = wes_palettes$Darjeeling2[2],
multixn  = wes_palettes$Darjeeling1[1],
multiyn  = wes_palettes$Darjeeling1[1],
multip   = "magenta4",
x3       = wes_palettes$FantasticFox1[2]
)
labs <- list(
xn = list(bquote(.(country)*","~x[n]*"*=new cases/day, actual till"~.(format.Date(latest_date,"%d.%m.%Y")))),
yn = list(bquote(.(country)*","~y[n]*"*=cumulative cases, actual till"~.(format.Date(latest_date,"%d.%m.%Y"))))
)
multimodnormval  <- modnorm(multimodel[1:length(countrydat$xn)], countrydat$xn)
multimodnormyval <- modnorm(beforecumcases+xntoyn(multimodel[1:length(countrydat$xn)]), countrydat$yn)
b.roman <- function(x){ return(paste0("(", as.roman(x), ")"))}
multilabd <- c()
for(i in 1:length(dates)){
multilabd <- c(multilabd, paste(b.roman(i), "from", format.Date(as.Date(as.character(dates[[i]][1])),"%d.%m")))
}
multilabd <- paste0(multilabd, collapse = "; ")
multilabp <- c()
for(i in 1:length(dates)){
multilabp <- c(multilabp, paste0(b.roman(i), " a=", phasepars[[i]][[2]], ", b=", phasepars[[i]][[3]]))
}
multilabp <- paste0(multilabp, paste0("; q=", phasepars[[i]][[1]]), collapse = "; ")
labs$multixn <- list(bquote("base"~.(length(dates))*"-phase model"~x[n]*"=new cases/day: "*
.(multilabd)*
"; ||x*-x||="*.(multimodnormval)*"  "*
.(multilabp)))
labs$multiyn <- list(bquote("base"~.(length(dates))*"-phase model"~y[n]*"=cumulative cases: "*
.(multilabd)*
"; ||y*-y||="*.(multimodnormyval)*"  "*
.(multilabp)))
mavgx1 <- movingavg(countrydat$xn[!is.na(countrydat$xn)])
countrydat$mavgx3 <- movingavg(mavgx1)
x3norm  <- modnorm(countrydat$xn,countrydat$mavgx3)
labs$x3 <- list(bquote("moving average x*(3); ||x*(3)-x*||="*.(x3norm)))
modeldat <- data.frame(date     = c(countrydat$date,as.Date(latest_date) + 1:forecastlen),
multixn  = multimodel,
multiyn  = beforecumcases + xntoyn(multimodel),
multipxn = multimodelp,
multipyn = beforecumcases + xntoyn(multimodelp))
plots[["xn"]] <- plot_multixn(countrydat, modeldat, cols, labs)
plots[["yn"]] <- plot_multiyn(countrydat, modeldat, cols, labs)
multilabp <- c()
for(i in 1:length(dates)){
multilabp <- c(multilabp,  paste0(b.roman(i),  " a=", phasepars[[i]][[2]], ", b=", phasepars[[i]][[3]]))
}
multilabp <- paste0(multilabp, paste0("; q=", phasepars[[i]][[1]]), collapse = "; ")
labs$multipxn <- list(bquote("periodic"~.(length(dates))*"-phase model"~x[n]*"=new cases/day: "*
.(multilabd)*
"; ||x*-x||="*.(multimodnormval)*"  "*
.(multilabp)))
labs$multipyn <- list(bquote("periodic"~.(length(dates))*"-phase model"~y[n]*"=cumulative cases: "*
.(multilabd)*
"; ||y*-y||="*.(multimodnormyval)*"  "*
.(multilabp)))
plots[["perxn"]] <- plot_multiperxn(countrydat, modeldat, cols, labs)
plots[["peryn"]] <- plot_multiperyn(countrydat, modeldat, cols, labs)
return(plots)
}
multilist <- list()
for(country in names(multidates)){
multilist[[country]] <- multiphasePlots(country, multidates[[country]], owiddat)
}
for(country in names(plotslist)){
for(p in names(plotslist[[country]])){
ggsave(filename = paste0(country, "-", p, ".pdf"),
plot     = plotslist[[country]][[p]],
path     = "./Plots",
height   = 10,
width    = 14,
units    = "cm"
)
}
}
for(country in names(multilist)){
for(p in names(multilist[[country]])){
ggsave(filename = paste0(country, "-", p, "mult.pdf"),
plot     = multilist[[country]][[p]],
path     = "Plots",
height   = 10,
width    = 16,
units    = "cm"
)
}
}
getwd
getwd()
multidates <- list(
"Italy"         = list(c("2020-12-16", "2021-01-01"),
c("2021-01-02", "2021-01-30")),
"United States" = list(c("2020-11-16", "2021-01-06"),
c("2021-01-07", "2021-01-30")),
"Ireland"       = list(c("2020-12-16", "2021-01-07"),
c("2021-01-08", "2021-01-30"))
)
multiphasePlots <- function(country, dates, data){
plots <- list()
crows <- grep(country, data$location)
countrydat <- data.frame(date = data$date[crows],
xn = data$new_cases[crows], yn = data$total_cases[crows])
if(nrow(countrydat[countrydat$date < dates[[1]][1],]) == 0)
beforecumcases <- 0
else
beforecumcases <- sum(countrydat$xn[countrydat$date < dates[[1]][1]])
countrydat  <- countrydat[countrydat$date >= dates[[1]][1],]
countrydat  <- countrydat[countrydat$date <= dates[[length(dates)]][2],]
latest_date <- countrydat$date[nrow(countrydat)]
forecastlen <- 5
multimodx <- function(x, multix, pars, oldp = rep(1,10), start=FALSE, len = 0){
q <- floor(pars[1])
a <- pars[2]
b <- pars[3]
fitstd <- length(multix)+1
if(start){
multix[fitstd:(fitstd+q-1)] <- x[1:q]
for(i in (fitstd+q):(fitstd+length(x)+len-1)){
multix[i] <- (1-b)*multix[i-1] + a*multix[i-q]
}
} else {
for(i in (fitstd):(fitstd+length(x)+len-1)){
multix[i] <- (1-b)*multix[i-1] + a*multix[i-q]
}
#multix[fitstd] <- b/oldp[[3]]*((1-oldp[[3]])*multix[fitstd-1] + oldp[[2]]*multix[fitstd-q])
#for(i in (fitstd+1):(fitstd+q-1)){
#  multix[i] <- (1-b)*multix[i-1] + b/oldp[[3]]*oldp[[2]]*multix[i-q]
#}
#for(i in (fitstd+q):(fitstd+length(x)+len-1)){
#  multix[i] <- (1-b)*multix[i-1] + a*multix[i-q]
#}
}
return(multix)
}
multimodxper <- function(par, q=7, x, multix, oldp = rep(1,10), start=FALSE, len = 0){
#a,b,c1,c2,p1,p2,n1,n2
#first day of this phase
fitstd <- length(multix)+1
an  <- par[1]*(1+par[3]*sin(2*pi*(1:(fitstd+length(x)+len-1) - par[7])/par[5]))
bn  <- par[2]*(1+par[4]*sin(2*pi*(1:(fitstd+length(x)+len-1) - par[8])/par[6]))
if(start){
multix[fitstd:(fitstd+q-1)] <- x[1:q]
for(i in (fitstd+q):(fitstd+length(x)+len-1)){
multix[i] <- (bn[i]*(1-bn[i-1]))*multix[i-1]/bn[i-1] +
(an[i-q]*bn[i])*multix[i-q]/bn[i-q]
}
} else {
for(i in fitstd:(fitstd+length(x)+len-1)){
multix[i] <- (bn[i]*(1-bn[i-1]))*multix[i-1]/bn[i-1] +
(an[i-q]*bn[i])*multix[i-q]/bn[i-q]
}
}
return(multix)
}
#Specific dates
multimodel  <- c()
multimodelp <- c()
phasepars   <- list()
for(i in 1:length(dates)){
phase    <- dates[[i]]
phasedat <- countrydat[countrydat$date >= phase[1] & countrydat$date <= phase[2],]
#get basic model for each phase first in order to get
# starting a and b to guess for periodic an and bn
aseq    <- seq(from = 0.1, to = 2.5, length.out = 50)
bseq    <- seq(from = 0.1, to = 0.9, length.out = 50)
qseq    <- 6:8
normdat <- expand.grid(q = qseq, a = aseq, b = bseq)
if(i == 1)
abnorm <- apply(normdat, 1, function(x) modnorm(multimodx(phasedat$xn, multimodel, x, start=TRUE), phasedat$xn))
else
abnorm <- apply(normdat, 1, function(x) modnorm(multimodx(phasedat$xn, multimodel, x, oldp = phasepars[[i-1]])[length(multimodel) + 1:nrow(phasedat)], phasedat$xn))
normalize <- function(x){
return((x-min(x))/(max(x)-min(x)))
}
normdat$abnorm  <- abnorm
#newnormdat      <- normdat %>% top_n(abnorm,n = -0.1*nrow(.))
#if(i == 1)
#  abnormy <- apply(newnormdat, 1, function(x) modnorm(beforecumcases + xntoyn(multimodx(phasedat$xn, multimodel, x[1:3], start=TRUE)), phasedat$yn))
#else
#  abnormy <- apply(newnormdat, 1, function(x) modnorm(beforecumcases + xntoyn(multimodx(phasedat$xn, multimodel, x[1:3], oldp = phasepars[[i-1]]))[length(multimodel)+1:nrow(phasedat)], phasedat$yn))
#newnormdat$abnormy  <- normalize(abnormy)
#newnormdat$combnorm <- newnormdat$abnorm + newnormdat$abnormy
tileoptim <- normdat[which.min(normdat$abnorm),1:3]
#tileoptim <- newnormdat[which.min(newnormdat$combnorm),1:3]
optimpars <- c(tileoptim$q, tileoptim$a, tileoptim$b)
q <- optimpars[1]
a <- optimpars[2]
b <- optimpars[3]
phasepars[[i]] <- round(optimpars,3)
if(i == 1 & i != length(dates))
multimodel <- multimodx(phasedat$xn, multimodel, optimpars, start=TRUE)
if(i == 1 & i == length(dates))
multimodel <- multimodx(phasedat$xn, multimodel, optimpars, start=TRUE, len=forecastlen)
if(i > 1 & i == length(dates))
multimodel <- multimodx(phasedat$xn, multimodel, optimpars, oldp = phasepars[[i-1]], len=forecastlen)
if(length(dates) > 2 & i %in% 2:(length(dates)-1))
multimodel <- multimodx(phasedat$xn, multimodel, optimpars, oldp = phasepars[[i-1]])
aseqper <- a*seq(from = 0.7, to = 1.3, length.out = 10)
bseqper <- b*seq(from = 0.7, to = 1.3, length.out = 10)
c_1seq  <- c_2seq <- seq(0.04, 0.2, length.out = 10)
n_1seq  <- n_2seq <- c(1,7)
p_1seq  <- p_2seq <- 6:7
normdatp <- expand.grid(a  = aseqper, b  = bseqper,
c1 = c_1seq,  c2 = c_2seq,
p1 = p_1seq,  p2 = p_2seq,
n1 = n_1seq,  n2 = n_2seq)
if(i == 1)
pernorm <- apply(normdatp, 1, function(par) modnorm(multimodxper(par, q = optimpars[1], phasedat$xn, multimodelp, start=TRUE), phasedat$xn))
else
pernorm <- apply(normdatp, 1, function(par) modnorm(multimodxper(par, q = optimpars[1], phasedat$xn, multimodelp)[length(multimodelp)+1:nrow(phasedat)], phasedat$xn))
normdatp$pernorm <- normalize(pernorm)
newnormdatp <- normdatp %>% top_n(pernorm,n = -0.05*nrow(.))
if(i == 1)
pernormy <- apply(newnormdatp, 1, function(par) modnorm(beforecumcases+xntoyn(multimodxper(par, q = optimpars[1], phasedat$xn, multimodelp, start=TRUE)), phasedat$yn))
else
pernormy <- apply(newnormdatp, 1, function(par) modnorm(beforecumcases+xntoyn(multimodxper(par, q = optimpars[1], phasedat$xn, multimodelp))[length(multimodelp)+1:nrow(phasedat)], phasedat$yn))
newnormdatp$pernormy <- normalize(pernormy)
newnormdatp$combnorm <- newnormdatp$pernorm + newnormdatp$pernormy
peroptim <- as.numeric(newnormdatp[which.min(newnormdatp$combnorm),1:8])
phasepars[[i]] <- c(phasepars[[i]],round(peroptim,3))
if(i == 1 & i != length(dates))
multimodelp <- multimodxper(peroptim, q = q, phasedat$xn, multimodelp, start=TRUE)
if(i == 1 & i == length(dates))
multimodelp <- multimodxper(peroptim, q = q, phasedat$xn, multimodelp, start=TRUE, len=forecastlen)
if(i > 1 & i == length(dates))
multimodelp <- multimodxper(peroptim, q = q, phasedat$xn, multimodelp, len=forecastlen)
if(length(dates) > 2 & i %in% 2:(length(dates)-1))
multimodelp <- multimodxper(peroptim, q = q, phasedat$xn, multimodelp)
}
cols <- list(
xn       = wes_palettes$Zissou1[1],
yn       = wes_palettes$Darjeeling2[2],
multixn  = wes_palettes$Darjeeling1[1],
multiyn  = wes_palettes$Darjeeling1[1],
multip   = "magenta4",
x3       = wes_palettes$FantasticFox1[2]
)
labs <- list(
xn = list(bquote(.(country)*","~x[n]*"*=new cases/day, actual till"~.(format.Date(latest_date,"%d.%m.%Y")))),
yn = list(bquote(.(country)*","~y[n]*"*=cumulative cases, actual till"~.(format.Date(latest_date,"%d.%m.%Y"))))
)
multimodnormval  <- modnorm(multimodel[1:length(countrydat$xn)], countrydat$xn)
multimodnormyval <- modnorm(beforecumcases+xntoyn(multimodel[1:length(countrydat$xn)]), countrydat$yn)
b.roman <- function(x){ return(paste0("(", as.roman(x), ")"))}
multilabd <- c()
for(i in 1:length(dates)){
multilabd <- c(multilabd, paste(b.roman(i), "from", format.Date(as.Date(as.character(dates[[i]][1])),"%d.%m")))
}
multilabd <- paste0(multilabd, collapse = "; ")
multilabp <- c()
for(i in 1:length(dates)){
multilabp <- c(multilabp, paste0(b.roman(i), " a=", phasepars[[i]][[2]], ", b=", phasepars[[i]][[3]]))
}
multilabp <- paste0(multilabp, paste0("; q=", phasepars[[i]][[1]]), collapse = "; ")
labs$multixn <- list(bquote("base"~.(length(dates))*"-phase model"~x[n]*"=new cases/day: "*
.(multilabd)*
"; ||x*-x||="*.(multimodnormval)*"  "*
.(multilabp)))
labs$multiyn <- list(bquote("base"~.(length(dates))*"-phase model"~y[n]*"=cumulative cases: "*
.(multilabd)*
"; ||y*-y||="*.(multimodnormyval)*"  "*
.(multilabp)))
mavgx1 <- movingavg(countrydat$xn[!is.na(countrydat$xn)])
countrydat$mavgx3 <- movingavg(mavgx1)
x3norm  <- modnorm(countrydat$xn,countrydat$mavgx3)
labs$x3 <- list(bquote("moving average x*(3); ||x*(3)-x*||="*.(x3norm)))
modeldat <- data.frame(date     = c(countrydat$date,as.Date(latest_date) + 1:forecastlen),
multixn  = multimodel,
multiyn  = beforecumcases + xntoyn(multimodel),
multipxn = multimodelp,
multipyn = beforecumcases + xntoyn(multimodelp))
plots[["xn"]] <- plot_multixn(countrydat, modeldat, cols, labs)
plots[["yn"]] <- plot_multiyn(countrydat, modeldat, cols, labs)
multilabp <- c()
for(i in 1:length(dates)){
multilabp <- c(multilabp,  paste0(b.roman(i),  " a=", phasepars[[i]][[2]], ", b=", phasepars[[i]][[3]]))
}
multilabp <- paste0(multilabp, paste0("; q=", phasepars[[i]][[1]]), collapse = "; ")
labs$multipxn <- list(bquote("periodic"~.(length(dates))*"-phase model"~x[n]*"=new cases/day: "*
.(multilabd)*
"; ||x*-x||="*.(multimodnormval)*"  "*
.(multilabp)))
labs$multipyn <- list(bquote("periodic"~.(length(dates))*"-phase model"~y[n]*"=cumulative cases: "*
.(multilabd)*
"; ||y*-y||="*.(multimodnormyval)*"  "*
.(multilabp)))
plots[["perxn"]] <- plot_multiperxn(countrydat, modeldat, cols, labs)
plots[["peryn"]] <- plot_multiperyn(countrydat, modeldat, cols, labs)
return(plots)
}
multilist <- list()
for(country in names(multidates)){
multilist[[country]] <- multiphasePlots(country, multidates[[country]], owiddat)
}
multilist$`United States`$perxn
multilist$`United States`$xn
multilist$`United States`$peryn
for(country in names(multilist)){
for(p in names(multilist[[country]])){
ggsave(filename = paste0(country, "-", p, "mult.pdf"),
plot     = multilist[[country]][[p]],
path     = "Plots",
height   = 10,
width    = 16,
units    = "cm"
)
}
}
